<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>ことばの雨</title>

<!-- 任意の日本語フォント（無くてもOK・自動フォールバック） -->
<link href="https://fonts.googleapis.com/css2?family=Kosugi+Maru&family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@600&display=swap" rel="stylesheet">

<style>
:root{
  --bg: #f7fafc;
  --ink: #222;
  --accent: #2563eb;
}
html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink);
  font-family: "BIZ UDP Gothic", system-ui, -apple-system, "Noto Sans JP", sans-serif; }
.app { min-height: 100%; display: grid; grid-template-rows: auto 1fr; }
header{
  position: sticky; top: 0;
  background: color-mix(in oklch, white 70%, var(--bg));
  border-bottom: 1px solid #e5e7eb;
  padding: 10px clamp(12px, 4vw, 24px);
  display: flex; flex-wrap: wrap; gap: 8px; align-items: center; z-index: 10;
}
h1{ font-size: clamp(16px, 2.2vw, 18px); margin: 0 8px 0 0; font-weight: 700; }
button{
  border: 0; border-radius: 999px; padding: 8px 14px; font-size: 15px; font-weight: 700;
  cursor: pointer; color: white; background: var(--accent);
}
button.stop{ background:#ef4444 } button:disabled{ opacity:.5 }
label, .status, .live, .speedControl { font-size: 14px; }
#stage{ position: relative; overflow: hidden; min-height: calc(100vh - 70px); }

/* 落下ワード */
.word{
  position: absolute; top: -2.5em; left: 0;
  padding: .25em .5em; line-height: 1.1; font-weight: 700;
  background: white; border-radius: .6em; box-shadow: 0 6px 18px rgba(0,0,0,.12);
  white-space: nowrap; user-select: none; will-change: transform;
  transition: opacity .12s ease, box-shadow .12s ease, border-color .12s ease;
  border: 2px solid transparent;
}
.word.interim{ opacity: .6; border-color: #c7d2fe; }
.word.final{ opacity: 1; border-color: #a7f3d0; }

/* ライブ表示＆速度 */
.live{ padding: 2px 8px; background:#fff; border-radius: 8px; border:1px solid #e5e7eb; }
.speedControl{ display:flex; align-items:center; gap:4px; }
.speedControl input[type="range"]{ width: 120px; }
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>音声→ことばの雨</h1>
    <button id="startBtn">スタート</button>
    <button id="stopBtn" class="stop" disabled>ストップ</button>
    <span id="status" class="status">準備OK</span>
    <span id="liveText" class="live"></span>
    <div class="speedControl" title="落下速度（mm/s）">
      <label for="speedRange">速度:</label>
      <input type="range" id="speedRange" min="50" max="500" value="200" step="10">
      <span id="speedValue">200</span>mm/s
    </div>
  </header>
  <main id="stage"></main>
</div>

<script>
// ==== 物理長さ（mm→px） ====
const MM_TO_PX = 96 / 25.4;
let speedMM = 200; // mm/s
let speedPxPerSec = speedMM * MM_TO_PX;

// ==== ランダム色・フォント ====
function randomColor(){
  const hue = Math.floor(Math.random()*360);
  const sat = 60 + Math.random()*30;    // 60〜90%
  const light = 50 + Math.random()*20;  // 50〜70%
  return `hsl(${hue},${sat}%,${light}%)`;
}
const fonts = [
  '"BIZ UDP Gothic", sans-serif',
  '"Hiragino Mincho ProN", serif',
  '"Yu Mincho", serif',
  '"Yu Gothic UI", sans-serif',
  '"Kosugi Maru", "Noto Sans JP", sans-serif',
  '"Noto Sans JP", sans-serif',
  '"Noto Serif JP", serif'
];
function randomFont(){ return fonts[Math.floor(Math.random() * fonts.length)]; }

// ==== ステージ&落下管理 ====
const stage = document.getElementById("stage");
let words = []; // {el,x,y,speed,width,height,text,isFinal}
let animId = null;
let lastTs = 0;
let stageHeight = stage.clientHeight; // レイアウト計測をキャッシュ
const MAX_WORDS = 80;                 // 負荷上限

function spawnWord(text, {isFinal=false, fontSizePx=null} = {}){
  if(!text) return;
  const el = document.createElement("div");
  el.className = "word " + (isFinal ? "final" : "interim");
  el.dataset.text = text;
  el.dataset.final = String(isFinal);
  el.textContent = text;
  el.style.color = randomColor();
  el.style.fontFamily = randomFont();
  if(fontSizePx){ el.style.fontSize = `${fontSizePx}px`; }

  stage.appendChild(el);
  const rect = el.getBoundingClientRect();
  const maxX = Math.max(0, stage.clientWidth - rect.width);
  const x = Math.random() * maxX;
  el.style.left = `${x}px`;

  words.push({
    el, x,
    y: -rect.height - 8, // 画面外ちょい上
    speed: speedPxPerSec,
    width: rect.width,
    height: rect.height,
    text,
    isFinal
  });

  // 上限を超えたら古い順に掃除
  while(words.length > MAX_WORDS){
    const w = words.shift();
    w.el.remove();
  }

  if(!animId){
    lastTs = performance.now();
    animId = requestAnimationFrame(tick);
  }
}

function upgradeToFinal(text){
  for(let i = words.length - 1; i >= 0; i--){
    const w = words[i];
    if(!w.isFinal && w.text === text){
      w.isFinal = true;
      w.el.classList.remove("interim");
      w.el.classList.add("final");
      return true;
    }
  }
  return false;
}

function tick(ts){
  const dt = Math.min(0.05, (ts - lastTs) / 1000);
  lastTs = ts;

  for(const w of words){
    w.y += w.speed * dt;
    w.el.style.transform = `translateY(${w.y}px)`;
  }
  // はみ出たら削除
  words = words.filter(w => {
    const alive = (w.y - 8) < stageHeight;
    if(!alive) w.el.remove();
    return alive;
  });

  if(words.length > 0){
    animId = requestAnimationFrame(tick);
  }else{
    animId = null;
  }
}

// ==== 音声認識 & 音量連動 ====
const startBtn = document.getElementById("startBtn");
const stopBtn  = document.getElementById("stopBtn");
const statusEl = document.getElementById("status");
const liveText = document.getElementById("liveText");
const speedRange = document.getElementById("speedRange");
const speedValue = document.getElementById("speedValue");

let recog = null;
let listening = false;
let interimTimer = null;
let lastInterim = "";
let lastInterimSpawned = ""; // 重複抑制

// マイク音量 → フォントサイズ
let currentVolume = 0;           // 0〜1 程度（RMS）
let audioCtx = null, analyser = null, micSource = null, micStream = null, meterRafId = null;

async function initMicVolumeMeter(){
  if(audioCtx) return;
  try{
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
    });
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
    analyser = audioCtx.createAnalyser();
    const source = audioCtx.createMediaStreamSource(micStream);
    micSource = source; source.connect(analyser);

    const dataArray = new Uint8Array(analyser.fftSize);
    const update = () => {
      analyser.getByteTimeDomainData(dataArray);
      let sum = 0;
      for(let i=0;i<dataArray.length;i++){
        const v = (dataArray[i]-128)/128; sum += v*v;
      }
      const rms = Math.sqrt(sum / dataArray.length);
      currentVolume = Math.min(1, rms * 3); // 0〜1に正規化
      meterRafId = requestAnimationFrame(update);
    };
    update();
  }catch(err){
    console.warn("マイク初期化失敗:", err);
    status("マイク初期化に失敗：" + err.message, true);
  }
}
function stopMicVolumeMeter(){
  if(meterRafId){ cancelAnimationFrame(meterRafId); meterRafId = null; }
  if(audioCtx){ try{ audioCtx.close(); }catch{} }
  audioCtx = null; analyser = null;
  if(micSource){ try{ micSource.disconnect(); }catch{} } micSource = null;
  if(micStream){ micStream.getTracks().forEach(t => t.stop()); } micStream = null;
  currentVolume = 0;
}
function volumeToFontSizePx(){
  const minPx = 18, maxPx = 64;
  return Math.round(minPx + (maxPx - minPx) * currentVolume);
}

// ステータス
function status(msg, isWarn=false){
  statusEl.textContent = msg;
  statusEl.style.background = isWarn ? "#fee2e2" : "";
  statusEl.style.color      = isWarn ? "#991b1b" : "";
}

// 認識セットアップ
function setupRecognition(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR){
    status("このブラウザは音声認識に未対応です（Chrome系 推奨）", true);
    startBtn.disabled = true; return null;
  }
  const r = new SR();
  r.lang = "ja-JP";
  r.interimResults = true;
  r.continuous = true;

  r.onstart = () => status("認識中…（話してください）");
  r.onerror = (e) => status("エラー：" + (e.error || "不明"), true);
  r.onend = () => {
    status("停止しました");
    listening = false;
    startBtn.disabled = false; stopBtn.disabled = true;
  };

  r.onresult = (ev) => {
    for(let i = ev.resultIndex; i < ev.results.length; i++){
      const res = ev.results[i];
      let text = res[0].transcript.trim();

      // ライブ表示
      liveText.textContent = text || "";

      if(res.isFinal){
        clearTimeout(interimTimer); interimTimer = null;
        if(!text) continue;

        const upgraded = upgradeToFinal(text);
        if(!upgraded){
          spawnWord(text, { isFinal:true, fontSizePx: volumeToFontSizePx() });
        }
        liveText.textContent = ""; lastInterim = ""; lastInterimSpawned = "";
      }else{
        clearTimeout(interimTimer);
        lastInterim = text;
        interimTimer = setTimeout(() => {
          const t = (lastInterim || "").trim();
          if(!t || t === lastInterimSpawned) return; // 同じ仮テキストの連投抑制
          lastInterimSpawned = t;
          spawnWord(t, { isFinal:false, fontSizePx: volumeToFontSizePx() });
        }, 300);
      }
    }
  };
  return r;
}

// ボタン
startBtn.addEventListener("click", async () => {
  if(!recog) recog = setupRecognition();
  if(!recog) return;
  await initMicVolumeMeter();

  try{
    recog.start();
    listening = true;
    startBtn.disabled = true; stopBtn.disabled = false;
    status("認識中…（話してください）");
  }catch(err){
    status("開始できませんでした：" + err.message, true);
  }
});
stopBtn.addEventListener("click", () => {
  if(recog && listening){ try{ recog.stop(); }catch{} }
  listening = false;
  startBtn.disabled = false; stopBtn.disabled = true;
  status("停止しました");
  liveText.textContent = "";
  clearTimeout(interimTimer); interimTimer = null; lastInterim = ""; lastInterimSpawned = "";
  stopMicVolumeMeter();
});

// 速度スライダー
speedRange.addEventListener("input", () => {
  speedMM = Number(speedRange.value);
  speedValue.textContent = speedMM;
  speedPxPerSec = speedMM * MM_TO_PX;
  words.forEach(w => w.speed = speedPxPerSec);
});

// リサイズ時：高さを更新（毎フレーム再計測しない）
function updateStageMetrics(){
  stageHeight = stage.clientHeight;
}
window.addEventListener("resize", updateStageMetrics);
window.addEventListener("orientationchange", updateStageMetrics);
updateStageMetrics();
</script>
</body>
</html>
