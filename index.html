<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>„Ç≥„Ç®„Ç´„Çø„Éû„É™„É≥È¢®„Éª„Å≤„Çâ„Åå„Å™„É¨„Ç§„É≥ÔºàÁ©ç„ÇÇ„ÇãÁâàÔºâ</title>
<style>
  html, body { height:100%; margin:0; background:#0b0e14; overflow:hidden; }
  #ui { position:fixed; top:8px; left:0; right:0; display:flex; gap:10px; justify-content:center; z-index:10; }
  button{
    background:#1c2435; color:#e7eefc; border:1px solid #32415e; padding:10px 16px; border-radius:12px;
    font-size:16px; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,.25);
  }
  button:hover{ border-color:#41588a }
  #leds{ position:fixed; top:54px; left:0; right:0; display:flex; justify-content:center; gap:10px; z-index:9; font-size:12px; color:#a9b4c6 }
  .led{ width:10px; height:10px; border-radius:50%; background:#525b6e; display:inline-block; margin-right:6px; vertical-align:middle }
  .on{ background:#2ecc71; box-shadow:0 0 0 3px rgba(46,204,113,.18) }
  canvas{ position:fixed; inset:0; }
  #hint{ position:fixed; bottom:8px; left:50%; transform:translateX(-50%); color:#8ea1c5; font-size:12px; opacity:.8 }
</style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">üéôÔ∏è „ÅØ„Åò„ÇÅ„Çã</button>
    <button id="stopBtn">‚èπ „Å®„ÇÅ„Çã</button>
  </div>
  <div id="leds">
    <span><span id="micLed" class="led"></span>„Éû„Ç§„ÇØ</span>
    <span><span id="asrLed" class="led"></span>Èü≥Â£∞Ë™çË≠ò</span>
  </div>
  <canvas id="cv"></canvas>
  <div id="hint">Â§ß„Åç„Å™Â£∞‚ÜíÂ§ß„Åç„ÅÑÊñáÂ≠ó„ÄÇ„ÇÜ„Å£„Åè„ÇäÈôç„Å£„Å¶„ÄÅ‰∏ã„Åß„Å°„ÇÉ„Çì„Å®Á©ç„ÇÇ„Çä„Åæ„Åô„ÄÇ</div>

<script>
(() => {
  // ===== Canvas
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cv.width = Math.floor(innerWidth * dpr);
    cv.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ===== UI
  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const micLed   = document.getElementById('micLed');
  const asrLed   = document.getElementById('asrLed');

  // ===== Audio (volume only)
  let mediaStream=null, audioCtx=null, analyser=null, floatBuf=null, rafVol=null, lastVol=0.15;
  function rms(buf){ let s=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; s+=v*v; } return Math.sqrt(s/buf.length); }
  function volumeLoop(){
    if(!analyser) return;
    analyser.getFloatTimeDomainData(floatBuf);
    let v = Math.min(0.5, rms(floatBuf));
    const norm = Math.pow(v/0.5, 0.6);
    lastVol = 0.1 + 0.9*norm;
    rafVol = requestAnimationFrame(volumeLoop);
  }
  async function startMic(){
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:false }, video:false
    });
    micLed.classList.add('on');
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(mediaStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    floatBuf = new Float32Array(analyser.fftSize);
    src.connect(analyser);
    volumeLoop();
  }
  function stopMic(){
    if(rafVol) cancelAnimationFrame(rafVol), rafVol=null;
    if(audioCtx) { audioCtx.close(); audioCtx=null; }
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
    analyser=null; floatBuf=null; micLed.classList.remove('on');
  }

  // ===== Speech recognition (ja-JP)
  let recognizer=null, recognizing=false; // ‚Üê‚òÖ „Åì„Åì„Å†„Åë„Å´ÁΩÆ„ÅèÔºàÈáçË§á„Åï„Åõ„Å™„ÅÑÔºâ
  function kataToHira(str){
    return str.replace(/[\u30A1-\u30FA\u30FC]/g, ch => ch==='„Éº' ? '„Éº' : String.fromCharCode(ch.charCodeAt(0) - 0x60));
  }
  const toHiraLoose = s => kataToHira(s);

  function setupASR(){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if(!SR) return null;
    const rec = new SR();
    rec.lang = 'ja-JP';
    rec.interimResults = true;
    rec.continuous = true;
    rec.maxAlternatives = 1;

    rec.onstart = ()=>{ asrLed.classList.add('on'); recognizing=true; };
    rec.onend   = ()=>{ asrLed.classList.remove('on'); recognizing=false; };
    rec.onerror = (e)=>{ console.warn('ASR error', e); };

    rec.onresult = (e)=>{
      let chunk = '';
      for(let i=e.resultIndex;i<e.results.length;i++){ chunk += e.results[i][0].transcript; }
      if(!chunk) return;
      const hira = toHiraLoose(chunk);
      for(const ch of hira){ if(/\s/.test(ch)) continue; spawnGlyph(ch); }
    };
    return rec;
  }

  // ===== Physics (Ë™øÊï¥Áâà)
  const glyphs = [];
  const gravity = 480;
  const airDrag = 0.0012;
  const windJitter = 18;
  const MAX_GLYPHS = 1500;

  function rand(min,max){ return min + Math.random()*(max-min); }
  function randomColor(){
    const h = Math.floor(rand(0,360));
    const s = Math.floor(rand(60,95));
    const l = Math.floor(rand(55,80));
    return `hsl(${h} ${s}% ${l}%)`;
  }
  function newSizeFromVolume(){ const min=20, max=120; return min + (max - min) * lastVol; }

  function spawnGlyph(ch){
    const size = newSizeFromVolume();
    const r = size/2;
    const x = rand(r, innerWidth - r);
    const y = -size - rand(0, 40);
    const vx = rand(-180, 180);
    const vy = rand(5, 60);
    const rot = rand(0, Math.PI*2);
    const rotSpeed = (Math.random()<0.6) ? rand(-3,3) : 0;
    const color = randomColor();
    glyphs.push({ ch, x, y, vx, vy, size, rot, rotSpeed, color, static:false });
    if(glyphs.length > MAX_GLYPHS){
      for(let i=0;i<glyphs.length;i++){
        if(!glyphs[i].static){ glyphs.splice(i,1); break; }
      }
    }
  }

  function collide(a,b){
    const ra=a.size*0.45, rb=b.size*0.45;
    return Math.abs(a.x-b.x) < (ra+rb) && Math.abs(a.y-b.y) < (ra+rb);
  }
  function resolveCollision(a,b){
    const nx = a.x - b.x, ny = a.y - b.y;
    const dist = Math.hypot(nx,ny) || 1;
    const ra=a.size*0.45, rb=b.size*0.45;
    const overlap = (ra+rb) - dist;
    if(overlap <= 0) return;
    const ux = nx/dist, uy = ny/dist;

    if(!a.static && !b.static){
      a.x += ux * (overlap/2); a.y += uy * (overlap/2);
      b.x -= ux * (overlap/2); b.y -= uy * (overlap/2);
    } else if(!a.static){
      a.x += ux * overlap; a.y += uy * overlap;
    } else if(!b.static){
      b.x -= ux * overlap; b.y -= uy * overlap;
    }

    const e = 0.25;
    const vaN = a.vx*ux + a.vy*uy;
    const vbN = b.vx*ux + b.vy*uy;
    if(!a.static){ a.vx += (vbN - vaN)*ux * (1+e); a.vy += (vbN - vaN)*uy * (1+e); }
    if(!b.static){ b.vx += (vaN - vbN)*ux * (1+e); b.vy += (vaN - vbN)*uy * (1+e); }

    const aOnTop = a.y < b.y && Math.abs(ux) < 0.7;
    const bOnTop = b.y < a.y && Math.abs(ux) < 0.7;
    if(!a.static && aOnTop && a.vy >= -40){ a.vx*=0.3; a.vy=0; a.static=true; a.rotSpeed=0; }
    if(!b.static && bOnTop && b.vy >= -40){ b.vx*=0.3; b.vy=0; b.static=true; b.rotSpeed=0; }
  }

  let lastT = performance.now();
  function step(){
    const now = performance.now();
    let dt = (now - lastT)/1000; lastT = now;
    const sub = Math.min(4, Math.max(1, Math.ceil(dt/0.01)));
    const h = dt / sub;

    for(let s=0;s<sub;s++){
      for(const g of glyphs){
        if(g.static) continue;
        g.vy += gravity * h;
        g.vx += (Math.random()-0.5) * windJitter * h;
        g.vx -= g.vx * 0.0012;
        g.vy -= g.vy * 0.0012;
        g.x += g.vx * h;
        g.y += g.vy * h;
        g.rot += g.rotSpeed * h;

        const r = g.size/2;
        if(g.x < r){ g.x = r; g.vx = Math.abs(g.vx)*0.6; }
        if(g.x > innerWidth - r){ g.x = innerWidth - r; g.vx = -Math.abs(g.vx)*0.6; }
        if(g.y >= innerHeight - r){
          g.y = innerHeight - r; g.vx *= 0.2; g.vy = 0; g.static = true; g.rotSpeed = 0;
        }
      }
      for(let i=0;i<glyphs.length;i++){
        for(let j=i+1;j<glyphs.length;j++){
          const a=glyphs[i], b=glyphs[j];
          if(collide(a,b)) resolveCollision(a,b);
        }
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,innerWidth,innerHeight);
    for(const g of glyphs){
      ctx.save();
      ctx.translate(g.x, g.y);
      ctx.rotate(g.rot);
      ctx.font = `bold ${g.size}px "Zen Maru Gothic", "YuKyokasho", "Noto Sans JP", "Hiragino Maru Gothic ProN", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = g.color;
      ctx.shadowColor = 'rgba(0,0,0,.45)';
      ctx.shadowBlur = 12;
      ctx.fillText(g.ch, 0, 0);
      ctx.restore();
    }
  }

  let rafAnim=null;
  function loop(){ step(); draw(); rafAnim = requestAnimationFrame(loop); }

  // ===== Start/StopÔºà‚òÖ„Åì„Åì„Åß„ÅØ„ÄåÂÜçÂÆ£Ë®Ä„Åó„Å™„ÅÑ„ÄçÔºâ
  function setupASROnce(){
    if(recognizer) return recognizer;
    recognizer = setupASR();
    return recognizer;
  }
  async function startAll(){
    try{ await startMic(); }catch(e){ alert('„Éû„Ç§„ÇØ„ÅÆ‰ΩøÁî®„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n'+e); return; }
    setupASROnce();
    if(recognizer && !recognizing){ try{ recognizer.start(); }catch(_){} }
    if(!rafAnim) loop();
  }
  function stopAll(){
    if(recognizer && recognizing){ try{ recognizer.stop(); }catch(_){} }
    recognizing=false; asrLed.classList.remove('on');
    stopMic();
    if(rafAnim) cancelAnimationFrame(rafAnim), rafAnim=null;
  }

  startBtn.addEventListener('click', startAll);
  stopBtn.addEventListener('click', stopAll);
  window.addEventListener('pagehide', stopAll);

  // „Éï„Ç©„É≥„Éà„Ç¶„Ç©„Éº„É†„Ç¢„ÉÉ„Éó
  ctx.font = 'bold 80px "Zen Maru Gothic", "Noto Sans JP", sans-serif';
  ctx.fillStyle = '#0b0e14';
  ctx.fillText('„ÅÇ', -9999, -9999);
})();
</script>
<link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@700&display=swap" rel="stylesheet">
</body>
</html>
